{"version":3,"sources":["../src/noise.ts"],"names":["x25519","Buffer","Wrap","DuplexPair","ensureBuffer","pipe","encode","decode","XXHandshake","IKHandshake","XXFallbackHandshake","generateKeypair","getPayload","uint16BEDecode","uint16BEEncode","decryptStream","encryptStream","KeyCache","logger","NOISE_MSG_MAX_LENGTH_BYTES","Noise","constructor","staticNoiseKey","earlyData","alloc","useNoisePipes","publicKey","publicKeyCreate","staticKeys","privateKey","secureOutbound","localPeer","connection","remotePeer","wrappedConnection","lengthEncoder","lengthDecoder","maxDataLength","handshake","performHandshake","isInitiator","conn","createSecureConnection","remoteEarlyData","secureInbound","params","payload","tryIK","load","ikHandshake","prologue","performIKHandshake","e","ephemeralKeys","getLocalEphemeralKeys","performXXFallbackHandshake","initialMsg","performXXHandshake","propose","exchange","finish","Error","message","store","getRemoteStaticKey","stage0","stage1","secure","user","network","unwrap"],"mappings":"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","sourcesContent":["import x25519 from 'bcrypto/lib/js/x25519';\nimport {Buffer} from \"buffer\";\nimport Wrap from 'it-pb-rpc';\nimport DuplexPair from 'it-pair/duplex';\nimport ensureBuffer from 'it-buffer';\nimport pipe from 'it-pipe';\nimport {encode, decode} from 'it-length-prefixed';\n\nimport {XXHandshake} from \"./handshake-xx\";\nimport {IKHandshake} from \"./handshake-ik\";\nimport {XXFallbackHandshake} from \"./handshake-xx-fallback\";\nimport {generateKeypair, getPayload} from \"./utils\";\nimport {uint16BEDecode, uint16BEEncode} from \"./encoder\";\nimport {decryptStream, encryptStream} from \"./crypto\";\nimport {bytes} from \"./@types/basic\";\nimport {INoiseConnection, KeyPair, SecureOutbound} from \"./@types/libp2p\";\nimport {Duplex} from \"it-pair\";\nimport {IHandshake} from \"./@types/handshake-interface\";\nimport {KeyCache} from \"./keycache\";\nimport {logger} from \"./logger\";\nimport PeerId from \"peer-id\";\nimport {NOISE_MSG_MAX_LENGTH_BYTES} from \"./constants\";\n\nexport type WrappedConnection = ReturnType<typeof Wrap>;\n\ntype HandshakeParams = {\n  connection: WrappedConnection;\n  isInitiator: boolean;\n  localPeer: PeerId;\n  remotePeer?: PeerId;\n};\n\nexport class Noise implements INoiseConnection {\n  public protocol = \"/noise\";\n\n  private readonly prologue = Buffer.alloc(0);\n  private readonly staticKeys: KeyPair;\n  private readonly earlyData?: bytes;\n  private useNoisePipes: boolean;\n\n  /**\n   *\n   * @param staticNoiseKey x25519 private key, reuse for faster handshakes\n   * @param earlyData\n   */\n  constructor(staticNoiseKey?: bytes, earlyData?: bytes) {\n    this.earlyData = earlyData || Buffer.alloc(0);\n    //disabled until properly specked\n    this.useNoisePipes = false;\n\n    if (staticNoiseKey) {\n      const publicKey = x25519.publicKeyCreate(staticNoiseKey);\n      this.staticKeys = {\n        privateKey: staticNoiseKey,\n        publicKey,\n      }\n    } else {\n      this.staticKeys = generateKeypair();\n    }\n  }\n\n  /**\n   * Encrypt outgoing data to the remote party (handshake as initiator)\n   * @param {PeerId} localPeer - PeerId of the receiving peer\n   * @param connection - streaming iterable duplex that will be encrypted\n   * @param {PeerId} remotePeer - PeerId of the remote peer. Used to validate the integrity of the remote peer.\n   * @returns {Promise<SecureOutbound>}\n   */\n  public async secureOutbound(localPeer: PeerId, connection: any, remotePeer: PeerId): Promise<SecureOutbound> {\n    const wrappedConnection = Wrap(\n      connection,\n      {\n        lengthEncoder: uint16BEEncode,\n        lengthDecoder: uint16BEDecode,\n        maxDataLength: NOISE_MSG_MAX_LENGTH_BYTES\n      }\n    );\n    const handshake = await this.performHandshake({\n      connection: wrappedConnection,\n      isInitiator: true,\n      localPeer,\n      remotePeer,\n    });\n    const conn = await this.createSecureConnection(wrappedConnection, handshake);\n\n    return {\n      conn,\n      remoteEarlyData: handshake.remoteEarlyData,\n      remotePeer: handshake.remotePeer,\n    }\n  }\n\n  /**\n   * Decrypt incoming data (handshake as responder).\n   * @param {PeerId} localPeer - PeerId of the receiving peer.\n   * @param connection - streaming iterable duplex that will be encryption.\n   * @param {PeerId} remotePeer - optional PeerId of the initiating peer, if known. This may only exist during transport upgrades.\n   * @returns {Promise<SecureOutbound>}\n   */\n  public async secureInbound(localPeer: PeerId, connection: any, remotePeer?: PeerId): Promise<SecureOutbound> {\n    const wrappedConnection = Wrap(\n      connection,\n      {\n        lengthEncoder: uint16BEEncode,\n        lengthDecoder: uint16BEDecode,\n        maxDataLength: NOISE_MSG_MAX_LENGTH_BYTES\n      }\n    );\n    const handshake = await this.performHandshake({\n      connection: wrappedConnection,\n      isInitiator: false,\n      localPeer,\n      remotePeer\n    });\n    const conn = await this.createSecureConnection(wrappedConnection, handshake);\n\n    return {\n      conn,\n      remoteEarlyData: handshake.remoteEarlyData,\n      remotePeer: handshake.remotePeer\n    };\n  }\n\n  /**\n   * If Noise pipes supported, tries IK handshake first with XX as fallback if it fails.\n   * If noise pipes disabled or remote peer static key is unknown, use XX.\n   * @param params\n   */\n  private async performHandshake(params: HandshakeParams): Promise<IHandshake> {\n    const payload = await getPayload(params.localPeer, this.staticKeys.publicKey, this.earlyData);\n    let tryIK = this.useNoisePipes;\n    if(params.isInitiator && KeyCache.load(params.remotePeer) === null) {\n      //if we are initiator and remote static key is unknown, don't try IK\n      tryIK = false;\n    }\n    // Try IK if acting as responder or initiator that has remote's static key.\n    if (tryIK) {\n      // Try IK first\n      const { remotePeer, connection, isInitiator } = params;\n      const ikHandshake = new IKHandshake(\n        isInitiator,\n        payload,\n        this.prologue,\n        this.staticKeys,\n        connection,\n        //safe to cast as we did checks\n        KeyCache.load(params.remotePeer) || Buffer.alloc(32),\n        remotePeer as PeerId,\n      );\n\n      try {\n        return await this.performIKHandshake(ikHandshake);\n      } catch (e) {\n        // IK failed, go to XX fallback\n        let ephemeralKeys;\n        if (params.isInitiator) {\n          ephemeralKeys = ikHandshake.getLocalEphemeralKeys();\n        }\n        return await this.performXXFallbackHandshake(params, payload, e.initialMsg, ephemeralKeys);\n      }\n    } else {\n      // run XX handshake\n      return await this.performXXHandshake(params, payload);\n    }\n  }\n\n  private async performXXFallbackHandshake(\n    params: HandshakeParams,\n    payload: bytes,\n    initialMsg: bytes,\n    ephemeralKeys?: KeyPair,\n  ): Promise<XXFallbackHandshake> {\n    const { isInitiator, remotePeer, connection } = params;\n    const handshake =\n      new XXFallbackHandshake(isInitiator, payload, this.prologue, this.staticKeys, connection, initialMsg, remotePeer, ephemeralKeys);\n\n    try {\n      await handshake.propose();\n      await handshake.exchange();\n      await handshake.finish();\n    } catch (e) {\n      logger(e);\n      throw new Error(`Error occurred during XX Fallback handshake: ${e.message}`);\n    }\n\n    return handshake;\n  }\n\n  private async performXXHandshake(\n    params: HandshakeParams,\n    payload: bytes,\n  ): Promise<XXHandshake> {\n    const { isInitiator, remotePeer, connection } = params;\n    const handshake = new XXHandshake(isInitiator, payload, this.prologue, this.staticKeys, connection, remotePeer);\n\n    try {\n      await handshake.propose();\n      await handshake.exchange();\n      await handshake.finish();\n\n      if (this.useNoisePipes && handshake.remotePeer) {\n        KeyCache.store(handshake.remotePeer, handshake.getRemoteStaticKey());\n      }\n    } catch (e) {\n      throw new Error(`Error occurred during XX handshake: ${e.message}`);\n    }\n\n    return handshake;\n  }\n\n  private async performIKHandshake(\n    handshake: IKHandshake,\n  ): Promise<IKHandshake> {\n\n    await handshake.stage0();\n    await handshake.stage1();\n\n    return handshake;\n  }\n\n  private async createSecureConnection(\n    connection: WrappedConnection,\n    handshake: IHandshake,\n  ): Promise<Duplex> {\n    // Create encryption box/unbox wrapper\n    const [secure, user] = DuplexPair();\n    const network = connection.unwrap();\n\n    pipe(\n      secure, // write to wrapper\n      ensureBuffer, // ensure any type of data is converted to buffer\n      encryptStream(handshake), // data is encrypted\n      encode({ lengthEncoder: uint16BEEncode }), // prefix with message length\n      network, // send to the remote peer\n      decode({ lengthDecoder: uint16BEDecode}), // read message length prefix\n      ensureBuffer, // ensure any type of data is converted to buffer\n      decryptStream(handshake), // decrypt the incoming data\n      secure // pipe to the wrapper\n    );\n\n    return user;\n  }\n\n\n}\n"],"file":"noise.js"}