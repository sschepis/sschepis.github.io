{"version":3,"sources":["../src/handshake-xx.ts"],"names":["Buffer","XX","decodePayload","getPeerIdFromPayload","verifySignedPayload","logger","logLocalStaticKeys","logLocalEphemeralKeys","logRemoteEphemeralKey","logRemoteStaticKey","logCipherState","decode0","decode1","decode2","encode0","encode1","encode2","XXHandshake","constructor","isInitiator","payload","prologue","staticKeypair","connection","remotePeer","handshake","xx","session","initSession","remoteEarlyData","alloc","propose","hs","s","messageBuffer","sendMessage","writeLP","e","receivedMessageBuffer","readLP","slice","valid","recvMessage","Error","re","exchange","plaintext","rs","decodedPayload","ns","setRemoteEarlyData","data","message","finish","encrypt","cs","getCS","encryptWithAd","decrypt","ciphertext","decryptWithAd","getRemoteStaticKey","encryption","cs1","cs2","from","buffer","byteOffset","length"],"mappings":"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","sourcesContent":["import { Buffer } from \"buffer\";\n\nimport { XX } from \"./handshakes/xx\";\nimport { KeyPair } from \"./@types/libp2p\";\nimport { bytes, bytes32 } from \"./@types/basic\";\nimport { NoiseSession } from \"./@types/handshake\";\nimport {IHandshake} from \"./@types/handshake-interface\";\nimport {\n  decodePayload,\n  getPeerIdFromPayload,\n  verifySignedPayload,\n} from \"./utils\";\nimport {\n  logger, \n  logLocalStaticKeys, \n  logLocalEphemeralKeys, \n  logRemoteEphemeralKey, \n  logRemoteStaticKey, \n  logCipherState, \n} from \"./logger\";\nimport {decode0, decode1, decode2, encode0, encode1, encode2} from \"./encoder\";\nimport { WrappedConnection } from \"./noise\";\nimport PeerId from \"peer-id\";\n\nexport class XXHandshake implements IHandshake {\n  public isInitiator: boolean;\n  public session: NoiseSession;\n  public remotePeer!: PeerId;\n  public remoteEarlyData: Buffer;\n\n  protected payload: bytes;\n  protected connection: WrappedConnection;\n  protected xx: XX;\n  protected staticKeypair: KeyPair;\n\n  private prologue: bytes32;\n\n  constructor(\n    isInitiator: boolean,\n    payload: bytes,\n    prologue: bytes32,\n    staticKeypair: KeyPair,\n    connection: WrappedConnection,\n    remotePeer?: PeerId,\n    handshake?: XX,\n  ) {\n    this.isInitiator = isInitiator;\n    this.payload = payload;\n    this.prologue = prologue;\n    this.staticKeypair = staticKeypair;\n    this.connection = connection;\n    if(remotePeer) {\n      this.remotePeer = remotePeer;\n    }\n    this.xx = handshake || new XX();\n    this.session = this.xx.initSession(this.isInitiator, this.prologue, this.staticKeypair);\n    this.remoteEarlyData = Buffer.alloc(0)\n  }\n\n  // stage 0\n  public async propose(): Promise<void> {\n    logLocalStaticKeys(this.session.hs.s)\n    if (this.isInitiator) {\n      logger(\"Stage 0 - Initiator starting to send first message.\");\n      const messageBuffer = this.xx.sendMessage(this.session, Buffer.alloc(0));\n      this.connection.writeLP(encode0(messageBuffer));\n      logger(\"Stage 0 - Initiator finished sending first message.\");\n      logLocalEphemeralKeys(this.session.hs.e)\n    } else {\n      logger(\"Stage 0 - Responder waiting to receive first message...\");\n      const receivedMessageBuffer = decode0((await this.connection.readLP()).slice());\n      const {valid} = this.xx.recvMessage(this.session, receivedMessageBuffer);\n      if(!valid) {\n        throw new Error(\"xx handshake stage 0 validation fail\");\n      }\n      logger(\"Stage 0 - Responder received first message.\");\n      logRemoteEphemeralKey(this.session.hs.re)\n    }\n  }\n\n  // stage 1\n  public async exchange(): Promise<void> {\n    if (this.isInitiator) {\n      logger('Stage 1 - Initiator waiting to receive first message from responder...');\n      const receivedMessageBuffer = decode1((await this.connection.readLP()).slice());\n      const {plaintext, valid} = this.xx.recvMessage(this.session, receivedMessageBuffer);\n      if(!valid) {\n        throw new Error(\"xx handshake stage 1 validation fail\");\n      }\n      logger('Stage 1 - Initiator received the message.');\n      logRemoteEphemeralKey(this.session.hs.re)\n      logRemoteStaticKey(this.session.hs.rs)\n\n      logger(\"Initiator going to check remote's signature...\");\n      try {\n        const decodedPayload = await decodePayload(plaintext);\n        this.remotePeer = this.remotePeer || await getPeerIdFromPayload(decodedPayload);\n        this.remotePeer = await verifySignedPayload(receivedMessageBuffer.ns, decodedPayload, this.remotePeer);\n        this.setRemoteEarlyData(decodedPayload.data)\n      } catch (e) {\n        throw new Error(`Error occurred while verifying signed payload: ${e.message}`);\n      }\n      logger(\"All good with the signature!\");\n    } else {\n      logger('Stage 1 - Responder sending out first message with signed payload and static key.');\n      const messageBuffer = this.xx.sendMessage(this.session, this.payload);\n      this.connection.writeLP(encode1(messageBuffer));\n      logger('Stage 1 - Responder sent the second handshake message with signed payload.')\n      logLocalEphemeralKeys(this.session.hs.e)\n    }\n  }\n\n  // stage 2\n  public async finish(): Promise<void> {\n    if (this.isInitiator) {\n      logger('Stage 2 - Initiator sending third handshake message.');\n      const messageBuffer = this.xx.sendMessage(this.session, this.payload);\n      this.connection.writeLP(encode2(messageBuffer));\n      logger('Stage 2 - Initiator sent message with signed payload.');\n    } else {\n      logger('Stage 2 - Responder waiting for third handshake message...');\n      const receivedMessageBuffer = decode2((await this.connection.readLP()).slice());\n      const {plaintext, valid} = this.xx.recvMessage(this.session, receivedMessageBuffer);\n      if(!valid) {\n        throw new Error(\"xx handshake stage 2 validation fail\");\n      }\n      logger('Stage 2 - Responder received the message, finished handshake.');\n\n      try {\n        const decodedPayload = await decodePayload(plaintext);\n        this.remotePeer = this.remotePeer || await getPeerIdFromPayload(decodedPayload);\n        await verifySignedPayload(this.session.hs.rs, decodedPayload, this.remotePeer);\n        this.setRemoteEarlyData(decodedPayload.data)\n      } catch (e) {\n        throw new Error(`Error occurred while verifying signed payload: ${e.message}`);\n      }\n    }\n    logCipherState(this.session)\n  }\n\n  public encrypt(plaintext: bytes, session: NoiseSession): bytes {\n    const cs = this.getCS(session);\n\n    return this.xx.encryptWithAd(cs, Buffer.alloc(0), plaintext);\n  }\n\n  public decrypt(ciphertext: bytes, session: NoiseSession): {plaintext: bytes; valid: boolean} {\n    const cs = this.getCS(session, false);\n    return this.xx.decryptWithAd(cs, Buffer.alloc(0), ciphertext);\n  }\n\n  public getRemoteStaticKey(): bytes {\n    return this.session.hs.rs;\n  }\n\n  private getCS(session: NoiseSession, encryption = true) {\n    if (!session.cs1 || !session.cs2) {\n      throw new Error(\"Handshake not completed properly, cipher state does not exist.\");\n    }\n\n    if (this.isInitiator) {\n      return encryption ? session.cs1 : session.cs2;\n    } else {\n      return encryption ? session.cs2 : session.cs1;\n    }\n  }\n\n  protected setRemoteEarlyData(data: Uint8Array|null|undefined): void {\n    if(data){\n      this.remoteEarlyData = Buffer.from(data.buffer, data.byteOffset, data.length);\n    }\n  }\n}\n"],"file":"handshake-xx.js"}