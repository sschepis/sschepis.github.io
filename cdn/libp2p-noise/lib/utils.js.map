{"version":3,"sources":["../src/utils.ts"],"names":["HKDF","x25519","SHA256","Buffer","PeerId","keys","pb","NoiseHandshakePayloadProto","NoiseHandshakePayload","generateKeypair","privateKey","privateKeyGenerate","publicKey","publicKeyCreate","getPayload","localPeer","staticPublicKey","earlyData","signedPayload","signPayload","getHandshakePayload","earlyDataPayload","alloc","createHandshakePayload","marshalPubKey","libp2pPublicKey","payloadInit","create","identityKey","identitySig","data","from","encode","finish","peerId","payload","privKey","sign","getPeerIdFromPayload","createFromPubKey","decodePayload","toObject","decode","concat","isValidPeerId","publicKeyProtobuf","generatedPeerId","id","equals","verifySignedPayload","noiseStaticKey","remotePeer","Error","generatedPayload","unmarshalPublicKey","verify","getHkdf","ck","ikm","info","prk","extract","okm","expand","k1","slice","k2","k3","isValidPublicKey","pk","publicKeyVerify"],"mappings":"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","sourcesContent":["import HKDF from 'bcrypto/lib/hkdf';\nimport x25519 from 'bcrypto/lib/js/x25519';\nimport SHA256 from 'bcrypto/lib/js/sha256';\nimport {Buffer} from \"buffer\";\nimport PeerId from \"peer-id\";\nimport {keys} from 'libp2p-crypto';\nimport {KeyPair} from \"./@types/libp2p\";\nimport {bytes, bytes32} from \"./@types/basic\";\nimport {Hkdf, INoisePayload} from \"./@types/handshake\";\nimport {pb} from \"./proto/payload\";\n\nconst NoiseHandshakePayloadProto = pb.NoiseHandshakePayload;\n\nexport function generateKeypair(): KeyPair {\n  const privateKey = x25519.privateKeyGenerate();\n  const publicKey = x25519.publicKeyCreate(privateKey);\n\n  return {\n    publicKey,\n    privateKey,\n  }\n}\n\nexport async function getPayload(\n  localPeer: PeerId,\n  staticPublicKey: bytes,\n  earlyData?: bytes,\n): Promise<bytes> {\n  const signedPayload = await signPayload(localPeer, getHandshakePayload(staticPublicKey));\n  const earlyDataPayload = earlyData || Buffer.alloc(0);\n\n  return await createHandshakePayload(\n    localPeer.marshalPubKey(),\n    signedPayload,\n    earlyDataPayload\n  );\n}\n\nexport async function createHandshakePayload(\n  libp2pPublicKey: bytes,\n  signedPayload: bytes,\n  earlyData?: bytes,\n): Promise<bytes> {\n\n  const payloadInit = NoiseHandshakePayloadProto.create({\n    identityKey: libp2pPublicKey,\n    identitySig: signedPayload,\n    data: earlyData || null,\n  });\n\n  return Buffer.from(NoiseHandshakePayloadProto.encode(payloadInit).finish());\n}\n\n\nexport async function signPayload(peerId: PeerId, payload: bytes): Promise<bytes> {\n  return peerId.privKey.sign(payload);\n}\n\nexport async function getPeerIdFromPayload(payload: pb.INoiseHandshakePayload): Promise<PeerId> {\n  return await PeerId.createFromPubKey(Buffer.from(payload.identityKey as Uint8Array));\n}\n\nexport async function decodePayload(payload: bytes|Uint8Array): Promise<pb.INoiseHandshakePayload> {\n  return NoiseHandshakePayloadProto.toObject(\n    NoiseHandshakePayloadProto.decode(Buffer.from(payload))\n  ) as INoisePayload;\n}\n\nexport function getHandshakePayload(publicKey: bytes): bytes {\n  return Buffer.concat([Buffer.from(\"noise-libp2p-static-key:\"), publicKey]);\n}\n\nasync function isValidPeerId(peerId: bytes, publicKeyProtobuf: bytes) {\n  const generatedPeerId = await PeerId.createFromPubKey(publicKeyProtobuf);\n  return generatedPeerId.id.equals(peerId);\n}\n\n/**\n * Verifies signed payload, throws on any irregularities.\n * @param {bytes} noiseStaticKey - owner's noise static key\n * @param {bytes} payload - decoded payload\n * @param {PeerId} remotePeer - owner's libp2p peer ID\n * @returns {Promise<PeerId>} - peer ID of payload owner\n */\nexport async function verifySignedPayload(\n  noiseStaticKey: bytes,\n  payload: pb.INoiseHandshakePayload,\n  remotePeer: PeerId\n): Promise<PeerId> {\n  const identityKey = Buffer.from(payload.identityKey as Uint8Array);\n  if (!(await isValidPeerId(remotePeer.id, identityKey))) {\n    throw new Error(\"Peer ID doesn't match libp2p public key.\");\n  }\n  const generatedPayload = getHandshakePayload(noiseStaticKey);\n  // Unmarshaling from PublicKey protobuf\n  const publicKey = keys.unmarshalPublicKey(identityKey);\n  if (!payload.identitySig || !publicKey.verify(generatedPayload, Buffer.from(payload.identitySig))) {\n    throw new Error(\"Static key doesn't match to peer that signed payload!\");\n  }\n  return PeerId.createFromPubKey(identityKey);\n}\n\nexport function getHkdf(ck: bytes32, ikm: bytes): Hkdf {\n  const info = Buffer.alloc(0);\n  const prk = HKDF.extract(SHA256, ikm, ck);\n  const okm = HKDF.expand(SHA256, prk, info, 96);\n\n  const k1 = okm.slice(0, 32);\n  const k2 = okm.slice(32, 64);\n  const k3 = okm.slice(64, 96);\n\n  return [k1, k2, k3];\n}\n\nexport function isValidPublicKey(pk: bytes): boolean {\n  return x25519.publicKeyVerify(pk.slice(0, 32));\n}\n"],"file":"utils.js"}