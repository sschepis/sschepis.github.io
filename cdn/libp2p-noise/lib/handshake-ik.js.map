{"version":3,"sources":["../src/handshake-ik.ts"],"names":["IK","Buffer","decode0","decode1","encode0","encode1","decodePayload","getPeerIdFromPayload","verifySignedPayload","FailedIKError","logger","logLocalStaticKeys","logRemoteStaticKey","logLocalEphemeralKeys","logRemoteEphemeralKey","logCipherState","IKHandshake","constructor","isInitiator","payload","prologue","staticKeypair","connection","remoteStaticKey","remotePeer","handshake","from","ik","session","initSession","remoteEarlyData","alloc","stage0","hs","s","rs","messageBuffer","sendMessage","writeLP","e","receivedMsg","readLP","receivedMessageBuffer","slice","plaintext","valid","recvMessage","Error","decodedPayload","setRemoteEarlyData","data","re","message","stage1","ns","decrypt","ciphertext","cs","getCS","decryptWithAd","encrypt","encryptWithAd","getLocalEphemeralKeys","encryption","cs1","cs2","buffer","byteOffset","length"],"mappings":"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","sourcesContent":["import {WrappedConnection} from \"./noise\";\nimport {IK} from \"./handshakes/ik\";\nimport {NoiseSession} from \"./@types/handshake\";\nimport {bytes, bytes32} from \"./@types/basic\";\nimport {KeyPair} from \"./@types/libp2p\";\nimport {IHandshake} from \"./@types/handshake-interface\";\nimport {Buffer} from \"buffer\";\nimport {decode0, decode1, encode0, encode1} from \"./encoder\";\nimport {decodePayload, getPeerIdFromPayload, verifySignedPayload} from \"./utils\";\nimport {FailedIKError} from \"./errors\";\nimport {\n  logger, \n  logLocalStaticKeys,\n  logRemoteStaticKey, \n  logLocalEphemeralKeys, \n  logRemoteEphemeralKey, \n  logCipherState\n} from \"./logger\";\nimport PeerId from \"peer-id\";\n\nexport class IKHandshake implements IHandshake {\n  public isInitiator: boolean;\n  public session: NoiseSession;\n  public remotePeer!: PeerId;\n  public remoteEarlyData: Buffer;\n\n  private payload: bytes;\n  private prologue: bytes32;\n  private staticKeypair: KeyPair;\n  private connection: WrappedConnection;\n  private ik: IK;\n\n  constructor(\n    isInitiator: boolean,\n    payload: bytes,\n    prologue: bytes32,\n    staticKeypair: KeyPair,\n    connection: WrappedConnection,\n    remoteStaticKey: bytes,\n    remotePeer?: PeerId,\n    handshake?: IK,\n  ) {\n    this.isInitiator = isInitiator;\n    this.payload = Buffer.from(payload);\n    this.prologue = prologue;\n    this.staticKeypair = staticKeypair;\n    this.connection = connection;\n    if(remotePeer) {\n      this.remotePeer = remotePeer;\n    }\n    this.ik = handshake || new IK();\n    this.session = this.ik.initSession(this.isInitiator, this.prologue, this.staticKeypair, remoteStaticKey);\n    this.remoteEarlyData = Buffer.alloc(0)\n  }\n\n  public async stage0(): Promise<void> {\n    logLocalStaticKeys(this.session.hs.s)\n    logRemoteStaticKey(this.session.hs.rs)\n    if (this.isInitiator) {\n      logger(\"IK Stage 0 - Initiator sending message...\");\n      const messageBuffer = this.ik.sendMessage(this.session, this.payload);\n      this.connection.writeLP(encode1(messageBuffer));\n      logger(\"IK Stage 0 - Initiator sent message.\");\n      logLocalEphemeralKeys(this.session.hs.e)\n    } else {\n      logger(\"IK Stage 0 - Responder receiving message...\");\n      const receivedMsg = await this.connection.readLP();\n      try {\n        const receivedMessageBuffer = decode1(receivedMsg.slice());\n        const {plaintext, valid} = this.ik.recvMessage(this.session, receivedMessageBuffer);\n        if(!valid) {\n          throw new Error(\"ik handshake stage 0 decryption validation fail\");\n        }\n        logger(\"IK Stage 0 - Responder got message, going to verify payload.\");\n        const decodedPayload = await decodePayload(plaintext);\n        this.remotePeer = this.remotePeer || await getPeerIdFromPayload(decodedPayload);\n        await verifySignedPayload(this.session.hs.rs, decodedPayload, this.remotePeer);\n        this.setRemoteEarlyData(decodedPayload.data);\n        logger(\"IK Stage 0 - Responder successfully verified payload!\");\n        logRemoteEphemeralKey(this.session.hs.re)\n      } catch (e) {\n        logger(\"Responder breaking up with IK handshake in stage 0.\");\n\n        throw new FailedIKError(receivedMsg, `Error occurred while verifying initiator's signed payload: ${e.message}`);\n      }\n    }\n  }\n\n  public async stage1(): Promise<void> {\n    if (this.isInitiator) {\n      logger(\"IK Stage 1 - Initiator receiving message...\");\n      const receivedMsg = (await this.connection.readLP()).slice();\n      const receivedMessageBuffer = decode0(Buffer.from(receivedMsg));\n      const {plaintext, valid} = this.ik.recvMessage(this.session, receivedMessageBuffer);\n      logger(\"IK Stage 1 - Initiator got message, going to verify payload.\");\n      try {\n        if(!valid) {\n          throw new Error(\"ik stage 1 decryption validation fail\");\n        }\n        const decodedPayload = await decodePayload(plaintext);\n        this.remotePeer = this.remotePeer || await getPeerIdFromPayload(decodedPayload);\n        await verifySignedPayload(receivedMessageBuffer.ns.slice(0, 32), decodedPayload, this.remotePeer);\n        this.setRemoteEarlyData(decodedPayload.data);\n        logger(\"IK Stage 1 - Initiator successfully verified payload!\");\n        logRemoteEphemeralKey(this.session.hs.re)\n      } catch (e) {\n        logger(\"Initiator breaking up with IK handshake in stage 1.\");\n        throw new FailedIKError(receivedMsg, `Error occurred while verifying responder's signed payload: ${e.message}`);\n      }\n    } else {\n      logger(\"IK Stage 1 - Responder sending message...\");\n      const messageBuffer = this.ik.sendMessage(this.session, this.payload);\n      this.connection.writeLP(encode0(messageBuffer));\n      logger(\"IK Stage 1 - Responder sent message...\");\n      logLocalEphemeralKeys(this.session.hs.e)\n    }\n    logCipherState(this.session)\n  }\n\n  public decrypt(ciphertext: bytes, session: NoiseSession): {plaintext: bytes; valid: boolean} {\n    const cs = this.getCS(session, false);\n    return this.ik.decryptWithAd(cs, Buffer.alloc(0), ciphertext);\n  }\n\n  public encrypt(plaintext: Buffer, session: NoiseSession): Buffer {\n    const cs = this.getCS(session);\n    return this.ik.encryptWithAd(cs, Buffer.alloc(0), plaintext);\n  }\n\n  public getLocalEphemeralKeys(): KeyPair {\n    if (!this.session.hs.e) {\n      throw new Error(\"Ephemeral keys do not exist.\");\n    }\n\n    return this.session.hs.e;\n  }\n\n  private getCS(session: NoiseSession, encryption = true) {\n    if (!session.cs1 || !session.cs2) {\n      throw new Error(\"Handshake not completed properly, cipher state does not exist.\");\n    }\n\n    if (this.isInitiator) {\n      return encryption ? session.cs1 : session.cs2;\n    } else {\n      return encryption ? session.cs2 : session.cs1;\n    }\n  }\n\n  private setRemoteEarlyData(data: Uint8Array|null|undefined): void {\n    if(data){\n      this.remoteEarlyData = Buffer.from(data.buffer, data.byteOffset, data.length);\n    }\n  }\n}\n"],"file":"handshake-ik.js"}