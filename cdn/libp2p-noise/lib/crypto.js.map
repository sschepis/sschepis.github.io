{"version":3,"sources":["../src/crypto.ts"],"names":["Buffer","NOISE_MSG_MAX_LENGTH_BYTES","NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG","encryptStream","handshake","source","chunk","chunkBuffer","from","buffer","byteOffset","length","i","end","data","encrypt","slice","session","decryptStream","plaintext","decrypted","valid","decrypt","Error"],"mappings":";;;;;;;;;;;;;;;;;;AAAA,SAASA,MAAT,QAAuB,QAAvB;AAEA,SAAQC,0BAAR,EAAoCC,sCAApC,QAAiF,aAAjF;AAMA;AACA,OAAO,SAASC,aAAT,CAAuBC,SAAvB,EAAwE;AAC7E;AAAA,mCAAO,WAAkBC,MAAlB,EAA0B;AAAA;AAAA;;AAAA;;AAAA;AAC/B,4CAA0BA,MAA1B,gOAAkC;AAAA,gBAAjBC,KAAiB;AAChC,gBAAMC,WAAW,GAAGP,MAAM,CAACQ,IAAP,CAAYF,KAAK,CAACG,MAAlB,EAA0BH,KAAK,CAACI,UAAhC,EAA4CJ,KAAK,CAACK,MAAlD,CAApB;;AAEA,eAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGL,WAAW,CAACI,MAAhC,EAAwCC,CAAC,IAAIV,sCAA7C,EAAqF;AACnF,gBAAIW,GAAG,GAAGD,CAAC,GAAGV,sCAAd;;AACA,gBAAIW,GAAG,GAAGN,WAAW,CAACI,MAAtB,EAA8B;AAC5BE,cAAAA,GAAG,GAAGN,WAAW,CAACI,MAAlB;AACD;;AAED,kBAAMG,IAAI,GAAGV,SAAS,CAACW,OAAV,CAAkBR,WAAW,CAACS,KAAZ,CAAkBJ,CAAlB,EAAqBC,GAArB,CAAlB,EAA6CT,SAAS,CAACa,OAAvD,CAAb;AACA,kBAAMH,IAAN;AACD;AACF;AAb8B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAchC,KAdD;;AAAA;AAAA;AAAA;AAAA;AAeD,C,CAGD;;AACA,OAAO,SAASI,aAAT,CAAuBd,SAAvB,EAAwE;AAC7E;AAAA,oCAAO,WAAkBC,MAAlB,EAA0B;AAAA;AAAA;;AAAA;;AAAA;AAC/B,6CAA0BA,MAA1B,0OAAkC;AAAA,gBAAjBC,KAAiB;AAChC,gBAAMC,WAAW,GAAGP,MAAM,CAACQ,IAAP,CAAYF,KAAK,CAACG,MAAlB,EAA0BH,KAAK,CAACI,UAAhC,EAA4CJ,KAAK,CAACK,MAAlD,CAApB;;AAEA,eAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGL,WAAW,CAACI,MAAhC,EAAwCC,CAAC,IAAIX,0BAA7C,EAAyE;AACvE,gBAAIY,GAAG,GAAGD,CAAC,GAAGX,0BAAd;;AACA,gBAAIY,GAAG,GAAGN,WAAW,CAACI,MAAtB,EAA8B;AAC5BE,cAAAA,GAAG,GAAGN,WAAW,CAACI,MAAlB;AACD;;AAED,kBAAML,KAAK,GAAGC,WAAW,CAACS,KAAZ,CAAkBJ,CAAlB,EAAqBC,GAArB,CAAd;AACA,kBAAM;AAACM,cAAAA,SAAS,EAAEC,SAAZ;AAAuBC,cAAAA;AAAvB,2CAAsCjB,SAAS,CAACkB,OAAV,CAAkBhB,KAAlB,EAAyBF,SAAS,CAACa,OAAnC,CAAtC,CAAN;;AACA,gBAAG,CAACI,KAAJ,EAAW;AACT,oBAAM,IAAIE,KAAJ,CAAU,oCAAV,CAAN;AACD;;AACD,kBAAMH,SAAN;AACD;AACF;AAjB8B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAkBhC,KAlBD;;AAAA;AAAA;AAAA;AAAA;AAmBD","sourcesContent":["import { Buffer } from \"buffer\";\nimport {IHandshake} from \"./@types/handshake-interface\";\nimport {NOISE_MSG_MAX_LENGTH_BYTES, NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG} from \"./constants\";\n\ninterface IReturnEncryptionWrapper {\n  (source: Iterable<Uint8Array>): AsyncIterableIterator<Uint8Array>;\n}\n\n// Returns generator that encrypts payload from the user\nexport function encryptStream(handshake: IHandshake): IReturnEncryptionWrapper {\n  return async function * (source) {\n    for await (const chunk of source) {\n      const chunkBuffer = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.length);\n\n      for (let i = 0; i < chunkBuffer.length; i += NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG) {\n        let end = i + NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG;\n        if (end > chunkBuffer.length) {\n          end = chunkBuffer.length;\n        }\n\n        const data = handshake.encrypt(chunkBuffer.slice(i, end), handshake.session);\n        yield data;\n      }\n    }\n  }\n}\n\n\n// Decrypt received payload to the user\nexport function decryptStream(handshake: IHandshake): IReturnEncryptionWrapper {\n  return async function * (source) {\n    for await (const chunk of source) {\n      const chunkBuffer = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.length);\n\n      for (let i = 0; i < chunkBuffer.length; i += NOISE_MSG_MAX_LENGTH_BYTES) {\n        let end = i + NOISE_MSG_MAX_LENGTH_BYTES;\n        if (end > chunkBuffer.length) {\n          end = chunkBuffer.length;\n        }\n\n        const chunk = chunkBuffer.slice(i, end);\n        const {plaintext: decrypted, valid} = await handshake.decrypt(chunk, handshake.session);\n        if(!valid) {\n          throw new Error(\"Failed to validate decrypted chunk\");\n        }\n        yield decrypted;\n      }\n    }\n  }\n}\n"],"file":"crypto.js"}